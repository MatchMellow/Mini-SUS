module DoctorSchedule where

import Types
import Data.List (find)

-- gera lista de horários de 20 em 20 min
gerarSlots20min :: String -> String -> String -> [Slot]
gerarSlots20min dia inicio fim =
  let minutosTot = toMin fim
      go m
        | m > minutosTot = []
        | otherwise =
            let hStr = toHora m
            in Slot { slDia = dia, slHora = hStr, slLivre = True } : go (m + 20)
  in go (toMin inicio)
  where
    toMin :: String -> Int
    toMin s =
      let (h, _:m) = span (/=':') s
      in read h * 60 + read m

    toHora :: Int -> String
    toHora m =
      let h = m `div` 60
          mm = m `mod` 60
          h'  = if h < 10 then '0':show h else show h
          mm' = if mm < 10 then '0':show mm else show mm
      in h' ++ ":" ++ mm'

-- médico libera um dia (ex.: "Segunda") das 08:00 às 16:00
liberarDiaMedico :: String -> String -> String -> [AgendaMedico] -> [AgendaMedico]
liberarDiaMedico crm dia hIni hFim agendas =
  let novosSlots = gerarSlots20min dia hIni hFim
  in case find (\a -> agMedicoCRM a == crm) agendas of
       Nothing ->
         AgendaMedico crm novosSlots : agendas
       Just ag ->
         -- sobrescreve só os slots daquele dia
         let outros = filter (\a -> agMedicoCRM a /= crm) agendas
             slotsFiltrados = filter (\s -> slDia s /= dia) (agSlots ag)
             slotsNovos     = slotsFiltrados ++ novosSlots
         in AgendaMedico crm slotsNovos : outros

-- marcar um slot como ocupado
ocuparSlot :: String -> String -> String -> [AgendaMedico] -> [AgendaMedico]
ocuparSlot crm dia hora agendas =
  map atualiza agendas
  where
    atualiza ag
      | agMedicoCRM ag /= crm = ag
      | otherwise =
          let slots' = map (\s -> if slDia s == dia && slHora s == hora
                                  then s { slLivre = False }
                                  else s) (agSlots ag)
          in ag { agSlots = slots' }
